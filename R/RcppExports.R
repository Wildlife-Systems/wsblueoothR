# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Track Address Paths Through Devices
#'
#' For each address, creates a chronological path showing which devices detected
#' the address over time. Returns the top N addresses by detection count.
#'
#' @param input_files Character vector of file paths to process.
#' @param top_n Integer. Number of top addresses to return (by detection count). Default is 10.
#' @param progress_interval Integer. How often to print progress (0 = no progress). Default is 10000.
#' @param device_filter Character vector. Filter by specific device IDs. Empty = all devices.
#' @param min_date String. Minimum date in YYYYMMDD format. Empty = no minimum.
#' @param max_date String. Maximum date in YYYYMMDD format. Empty = no maximum.
#'
#' @return A data.frame with columns:
#'   \describe{
#'     \item{address}{Bluetooth MAC address}
#'     \item{detection_count}{Total number of detections}
#'     \item{device_count}{Number of unique devices that detected this address}
#'     \item{first_seen}{First detection timestamp (YYYYMMDD-HHMMSS)}
#'     \item{last_seen}{Last detection timestamp (YYYYMMDD-HHMMSS)}
#'     \item{path}{Chronological path through devices (e.g., "16 -> 18 -> 16 -> 21")}
#'   }
#'
#' @examples
#' \dontrun{
#' paths <- get_address_paths("data/combined_sort.txt", top_n = 20)
#' paths <- get_address_paths(c("file1.txt", "file2.txt"), top_n = 50)
#' }
#'
#' @export
calculate_address_paths <- function(input_files, top_n = 10L, progress_interval = 10000L, device_filter = characterVector(), min_date = "", max_date = "") {
    .Call(`_wsbluetoothR_calculate_address_paths`, input_files, top_n, progress_interval, device_filter, min_date, max_date)
}

#' Calculate Address Duration per Device and Day
#'
#' Calculates the time duration (in seconds) that each Bluetooth address
#' was detected by each device on each day. The duration is calculated as
#' the time difference between the first and last detection of that address
#' on that device on that day.
#'
#' @param input_files Character vector of file paths to process.
#' @param progress_interval Integer. How often to print progress (0 = no progress). Default is 10000.
#' @param low_memory Logical. If TRUE, processes one device at a time to reduce memory usage. Default is FALSE.
#'
#' @return A data.frame with columns:
#'   \describe{
#'     \item{device}{Device ID}
#'     \item{date}{Date in YYYY-MM-DD format}
#'     \item{address}{Bluetooth MAC address}
#'     \item{first_seen}{Timestamp of first detection (YYYYMMDD-HHMMSS)}
#'     \item{last_seen}{Timestamp of last detection (YYYYMMDD-HHMMSS)}
#'     \item{duration_seconds}{Time duration in seconds between first and last detection}
#'     \item{detection_count}{Number of times this address was detected}
#'   }
#'
#' @examples
#' \dontrun{
#' durations <- calculate_address_duration("data/combined_sort.txt")
#' # Multiple files
#' durations <- calculate_address_duration(c("file1.txt", "file2.txt"))
#' }
#'
#' @export
calculate_address_duration <- function(input_files, progress_interval = 10000L, device_filter = characterVector(), min_date = "", max_date = "", include_list = characterVector(), exclude_list = characterVector(), low_memory = FALSE) {
    .Call(`_wsbluetoothR_calculate_address_duration`, input_files, progress_interval, device_filter, min_date, max_date, include_list, exclude_list, low_memory)
}

#' Calculate Average Address Duration per Device and Time Period
#'
#' Calculates statistics (median, mean, etc.) for address durations across all Bluetooth addresses
#' for each device grouped by time period (hour or day). This gives you the typical
#' detection duration for a device in each time window.
#'
#' @param input_files Character vector of file paths to process.
#' @param progress_interval Integer. How often to print progress (0 = no progress). Default is 10000.
#' @param device_filter Character vector. Filter by specific device IDs. Empty = all devices.
#' @param min_date String. Minimum date in YYYYMMDD format. Empty = no minimum.
#' @param max_date String. Maximum date in YYYYMMDD format. Empty = no maximum.
#' @param include_list Character vector. Only include records where name starts with these prefixes.
#' @param exclude_list Character vector. Exclude records where name starts with these prefixes.
#' @param time_group String. Time grouping: "day" or "hour". Default is "day".
#'
#' @return A data.frame with columns:
#'   \describe{
#'     \item{device}{Device ID}
#'     \item{datetime}{Time period (YYYY-MM-DD for day, YYYY-MM-DD-HH for hour)}
#'     \item{median_duration_seconds}{Median duration across all addresses in this period}
#'     \item{mean_duration_seconds}{Mean duration across all addresses in this period}
#'     \item{min_duration_seconds}{Minimum duration}
#'     \item{max_duration_seconds}{Maximum duration}
#'     \item{address_count}{Number of unique addresses detected}
#'     \item{total_detections}{Total detection count}
#'   }
#'
#' @export
calculate_average_address_duration <- function(input_files, progress_interval = 10000L, device_filter = characterVector(), min_date = "", max_date = "", include_list = characterVector(), exclude_list = characterVector(), low_memory = FALSE, time_group = "day") {
    .Call(`_wsbluetoothR_calculate_average_address_duration`, input_files, progress_interval, device_filter, min_date, max_date, include_list, exclude_list, low_memory, time_group)
}

get_unique_device_names <- function(input_file, progress_interval = 10000L) {
    .Call(`_wsbluetoothR_get_unique_device_names`, input_file, progress_interval)
}

find_common_prefixes_cpp <- function(device_names, min_length = 3L, min_count = 2L, stop_char = "") {
    .Call(`_wsbluetoothR_find_common_prefixes_cpp`, device_names, min_length, min_count, stop_char)
}

process_bluetooth_files <- function(input_files, progress_interval = 1000L, include_prefixes = NULL, exclude_prefixes = NULL) {
    .Call(`_wsbluetoothR_process_bluetooth_files`, input_files, progress_interval, include_prefixes, exclude_prefixes)
}

