% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/median_duration_analysis.R
\name{get_average_address_duration}
\alias{get_average_address_duration}
\title{Calculate Average Address Duration per Device and Time Period}
\usage{
get_average_address_duration(
  files,
  progress_interval = 10000,
  verbose = TRUE,
  devices = NULL,
  min_date = NULL,
  max_date = NULL,
  include_names = NULL,
  exclude_names = NULL,
  low_memory = FALSE,
  time_group = "day"
)
}
\arguments{
\item{files}{Character vector of file paths to process. Can be a single file or multiple files.}

\item{progress_interval}{Integer. How often to print progress messages (0 = no progress). Default is 10000.}

\item{verbose}{Logical. Whether to print progress messages. Default is TRUE.}

\item{devices}{Character vector. Filter by specific device IDs. NULL = all devices. Default is NULL.}

\item{min_date}{Character or Date. Minimum date to include (YYYY-MM-DD or Date object). NULL = no minimum. Default is NULL.}

\item{max_date}{Character or Date. Maximum date to include (YYYY-MM-DD or Date object). NULL = no maximum. Default is NULL.}

\item{include_names}{Character vector. Only include records where name starts with one of these prefixes. NULL = include all. Default is NULL.}

\item{exclude_names}{Character vector. Exclude records where name starts with one of these prefixes. NULL = exclude none. Default is NULL.}

\item{low_memory}{Logical. If TRUE, processes one device at a time to reduce memory usage (slower but uses less RAM). Default is FALSE.}

\item{time_group}{Character. Time grouping: "day" or "hour". Default is "day".}
}
\value{
A data.frame with columns:
\describe{
\item{device}{Device ID}
\item{datetime}{Time period as POSIXct (for hour) or Date (for day)}
\item{median_duration_seconds}{Median duration in seconds across all addresses}
\item{mean_duration_seconds}{Mean duration in seconds across all addresses}
\item{min_duration_seconds}{Minimum duration in seconds}
\item{max_duration_seconds}{Maximum duration in seconds}
\item{address_count}{Number of unique addresses detected}
\item{total_detections}{Total number of detections across all addresses}
}
}
\description{
Calculates statistics (median, mean, etc.) for address durations across all Bluetooth addresses
detected by each device grouped by time period (hour or day). Unlike \code{get_address_duration()},
which returns one row per device-date-address combination, this function aggregates
across all addresses and returns the median duration for each device-time period.
}
\details{
This function first calculates daily durations using \code{get_address_duration()},
then aggregates by device and time period to compute median and other summary statistics
across all addresses. This is useful for understanding typical detection patterns
per device over time.

When \code{time_group = "hour"}, results are grouped by device and hour (e.g., all detections
on device 16 between 14:00 and 14:59 on 2025-08-15).

When \code{time_group = "day"}, results are grouped by device and day (e.g., all detections
on device 16 on 2025-08-15).
}
\examples{
\dontrun{
# Daily grouping (default)
median_durations <- get_average_address_duration("data/combined_sort.txt")

# Hourly grouping
hourly_medians <- get_average_address_duration("data.txt", time_group = "hour")

# Filter by device
median_durations <- get_average_address_duration("data.txt", devices = "16")

# Filter by date range with hourly grouping
median_durations <- get_average_address_duration("data.txt", 
                                                 min_date = "2025-08-01", 
                                                 max_date = "2025-08-31",
                                                 time_group = "hour")

# Find time periods with highest median duration
library(dplyr)
median_durations \%>\%
  arrange(desc(median_duration_seconds)) \%>\%
  head(10)
}

}
