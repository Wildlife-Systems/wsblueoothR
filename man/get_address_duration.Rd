% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/duration_analysis.R
\name{get_address_duration}
\alias{get_address_duration}
\title{Calculate Address Duration per Device and Day}
\usage{
get_address_duration(
  files,
  progress_interval = 10000,
  verbose = TRUE,
  devices = NULL,
  min_date = NULL,
  max_date = NULL,
  include_names = NULL,
  exclude_names = NULL,
  low_memory = FALSE
)
}
\arguments{
\item{files}{Character vector of file paths to process. Can be a single file or multiple files.}

\item{progress_interval}{Integer. How often to print progress messages (0 = no progress). Default is 10000.}

\item{verbose}{Logical. Whether to print progress messages. Default is TRUE.}

\item{devices}{Character vector. Filter by specific device IDs. NULL = all devices. Default is NULL.}

\item{min_date}{Character or Date. Minimum date to include (YYYY-MM-DD or Date object). NULL = no minimum. Default is NULL.}

\item{max_date}{Character or Date. Maximum date to include (YYYY-MM-DD or Date object). NULL = no maximum. Default is NULL.}

\item{include_names}{Character vector. Only include records where name starts with one of these prefixes. NULL = include all. Default is NULL.}

\item{exclude_names}{Character vector. Exclude records where name starts with one of these prefixes. NULL = exclude none. Default is NULL.}

\item{low_memory}{Logical. If TRUE, processes one device at a time to reduce memory usage (slower but uses less RAM). Default is FALSE.}
}
\value{
A data.frame with columns:
\describe{
\item{device}{Device ID}
\item{date}{Date in YYYY-MM-DD format}
\item{address}{Bluetooth MAC address}
\item{first_seen}{Timestamp of first detection (YYYYMMDD-HHMMSS)}
\item{last_seen}{Timestamp of last detection (YYYYMMDD-HHMMSS)}
\item{duration_seconds}{Time duration in seconds between first and last detection}
\item{detection_count}{Number of times this address was detected}
}
}
\description{
Calculates the time duration (in seconds) that each Bluetooth address
was detected by each device on each day. The duration is calculated as
the time difference between the first and last detection of that address
on that device on that day.
}
\details{
This function processes Bluetooth detection data to calculate how long each
device was in range of each sensor on each day. The duration is based on the
time span between the first and last detection, not the total time detected.

For example, if a device is detected at 10:00:00 and 10:05:00, the duration
is 300 seconds (5 minutes), regardless of how many times it was detected
in between.

Filters are applied during data reading for efficiency, so filtering by device
or date range on large files will be much faster than filtering the results afterwards.
}
\examples{
\dontrun{
# Single file
durations <- get_address_duration("data/combined_sort.txt")

# Multiple files
durations <- get_address_duration(c("file1.txt", "file2.txt"))

# Filter by device
durations <- get_address_duration("data.txt", devices = c("16", "17"))

# Filter by date range
durations <- get_address_duration("data.txt", 
                                  min_date = "2025-08-01", 
                                  max_date = "2025-08-31")

# Combined filters
durations <- get_address_duration("data.txt", 
                                  devices = "16",
                                  min_date = as.Date("2025-08-15"))

# Filter by name prefix (include only certain devices)
durations <- get_address_duration("data.txt", 
                                  include_names = c("iPhone", "Galaxy"))

# Exclude certain name prefixes
durations <- get_address_duration("data.txt", 
                                  exclude_names = c("Unknown", "[TV]"))

# Analyze durations
summary(durations$duration_seconds)

# Find addresses detected for longest duration on a specific device
library(dplyr)
durations \%>\%
  filter(device == "16") \%>\%
  arrange(desc(duration_seconds)) \%>\%
  head(10)
}

}
